{"pageProps":{"postData":{"frontmatter":{"title":"Inflation - Looking Back!","description":"See how the piggy bank :P can digest part of your money.","date":"June 8, 2021","topic":{"id":"investing","name":"Investing","image":"investing.png","description":"The piggy bank digests a good amount of the savings! There is only one way to get away ... investing. BUT, there is a hidden enemy, Speculation!","color":"bg-green-300"},"tags":[{"id":"python","name":"python","image":"python-header.png","description":"Python is very handy in investing","color":"bg-green-300","icon":"python.svg"}],"author":{"id":"chris","name":"Chris","image":"https://s.gravatar.com/avatar/db809ecfa64d56da4bd9704c8393005a?s=80","description":"Software Engineer, passionate about ..."},"img":"/static/no-piggy-bank.png","colab":"https://drive.google.com/file/d/1DUyPzZAVkdg1QMiPNnkbBMB1cu2AT33o/view?usp=sharing"},"post":{"content":"\nIn [Inflation - Planning Forward](/post/inflation-planning-future-cash-flows) we picked a static annual inflation rate to plan the financing of future expenses. In this article we will use the inflation historical data to determine how inflation had affected our savings. \n\n\n<details><summary>Package Installation</summary>\n<p>\n\n```python\n%%capture\nimport pandas as pd\nimport numpy as np\nfrom datetime import datetime\nfrom dateutil.relativedelta import relativedelta\nimport matplotlib.pyplot as plt\n!pip install -q requests\n!pip install -q pyscbwrapper\n```\n\n</p>\n</details>\n\nLet us assume that 10 years ago a person started depositing 500\\$ of hers/his salary to the bank once a month.\n\n\n```python\nSAVINGS_PER_MONTH = 500\ndef generate_montly_savings_account_balance(monthly_savings):\n  today = datetime.today()\n  beginning_of_month = datetime(today.year, today.month, 1)\n  ten_years_ago = beginning_of_month - relativedelta(years=10)\n\n  savings_df = pd.DataFrame({\n      'date': pd.date_range(start=ten_years_ago, end=beginning_of_month, closed=None, freq='MS'),\n      'savings': monthly_savings\n      })\n  savings_df = savings_df.set_index(['date'])\n  return savings_df\n\nsavings_df = generate_montly_savings_account_balance(SAVINGS_PER_MONTH)\nsavings_accumulated = savings_df.savings.cumsum()\ncurrent_total = savings_accumulated[savings_df.index[-1]]\nsavings_plot = savings_accumulated.plot(figsize=(14,7))\nsavings_plot.set_title('Deposit account growth')\nsavings_plot.set_xlabel('Date')\nsavings_plot.set_ylabel('Amount')\nsavings_plot.axhline(current_total, color='g', linestyle='--', label='{:0.2f}'.format(current_total))\nsavings_plot.legend()\nplt.show()\n```\n\n![png](inflation-looking-back/inflation-looking-back_3_0.png)\n\nNext, let's fetch the US inflation rates from the [U.S. BUREAU OF LABOR STATISTICS](https://www.bls.gov/) and see how it advanced over the last decade.\n\n```python\ndef get_us_cpi(start_year='2012', end_year = '2021'):\n  '''\n    from https://www.bls.gov/developers/api_python.htm#python1\n  '''\n  import requests\n  import json\n  headers = {'Content-type': 'application/json'}\n  data = json.dumps({\"seriesid\": ['SUUR0000SA0'],\"startyear\":start_year, \"endyear\":end_year})\n  p = requests.post('https://api.bls.gov/publicAPI/v1/timeseries/data/', data=data, headers=headers)\n  json_data = json.loads(p.text)\n  cpi_list = []\n  for series in json_data['Results']['series']:\n    seriesId = series['seriesID']\n    for item in series['data']:\n      year = item['year']\n      period = item['period']\n      value = item['value']\n  \n      if 'M01' <= period <= 'M12':\n        datetime_object = datetime.strptime('{}-{}-01'.format(year, period[1:]), '%Y-%m-%d')\n        value = float(value)\n        cpi_list.append({\n                    'date': datetime_object,\n                    'cpi':  0.001 if value == 0.0 else value\n                  })\n  cpi= pd.DataFrame(cpi_list)\n  cpi['date'] = cpi['date'].astype('datetime64[ns]')\n  cpi = cpi.set_index('date')\n  cpi = cpi.sort_values(by='date')\n  return cpi\n\nus_cpi = get_us_cpi()\ninflation_rate_change_plot = us_cpi['cpi'].plot(figsize=(14,7))\ninflation_rate_change_plot.set_title('Inflation Monthly')\ninflation_rate_change_plot.set_xlabel('Date')\ninflation_rate_change_plot.set_ylabel('Infaltion Value')\nplt.show()\n```\n\n![png](inflation-looking-back/inflation-looking-back_5_0.png)\n    \nWe will now see how inflation would affect the purchase value of 1\\$. To do that we will calculate the monthly percentage change and then create what we previously referred to as [wealth index](/post/from-portfolio-wealth-index-to-index-fund) of 1\\$.\n\n\n```python\ndef plot_cpi_on_unit(cpi, unit='$'):\n  if 'pct_change' not in cpi.columns:\n    cpi['pct_change'] = cpi['cpi'].pct_change().dropna() \n  change_on_unit = 1 * (1+cpi['pct_change'][savings_df.index[0]:]).cumprod()\n  change_on_unit_plot = change_on_unit.plot(figsize=(14,7))\n  change_on_unit_plot.set_title(f\"How Inflation affects 1 {unit}\")\n  change_on_unit_plot.set_xlabel('Date')\n  change_on_unit_plot.set_ylabel(f\"Worth of 1 {unit}\")\n  change_on_unit_plot.axhline(change_on_unit[-1], color='g', linestyle='--', label='{:0.2f}'.format(change_on_unit[-1]))\n  change_on_unit_plot.legend()\n  plt.show()\n\nplot_cpi_on_unit(us_cpi, unit='$')\n```\n\n![png](inflation-looking-back/inflation-looking-back_8_0.png)\n\nWhat the graph shows above is that buying a product at 1\\$ in the beginning of 2012, this exact same product would today cost 1.15\\$. If you had saved the dollar in an account you would today miss 0.15\\$ to be able to purchase the product. In practice, you have lost 0.15\\$!\n\nNow that we have the percentage changes of the inflation, lets calculate the total loss of our savings all these years. For each month we add money to the cash account we have to start measuring the impact of inflation from that point on.\n\n```python\ndef plot_loss_on_savings(savings, cpi):\n  last_valid_index = cpi.last_valid_index()\n  s = pd.DataFrame(columns=savings.index.array, index=savings.index)\n  for col in s.columns:\n    wealth_index = savings['savings'][col] * (1+cpi['pct_change'][col:last_valid_index]).cumprod()\n    s[col] = wealth_index - savings['savings'][col]\n  inf_losses = s.sum(axis=1)\n  ax = inf_losses.plot(figsize=(14,7))\n  ax.set_title('Total loss due to inflation')\n  ax.set_xlabel('Date')\n  ax.set_ylabel('Loss in $')\n  ax.axhline(inf_losses[last_valid_index], color='r', linestyle='--', label='{:0.2f}'.format(inf_losses[last_valid_index]))\n  ax.legend()\n  ax.plot()\n\nplot_loss_on_savings(savings_df, us_cpi)\n```\n\n![png](inflation-looking-back/inflation-looking-back_11_0.png)\n    \n\n5349\\$ is the loss of saving in the bank without investing. That is almost 10% of the total account value!\n\n## Sweden\n\nHaving a special interest in the Swedish market, I will include the code needed to fetch inflation statistics from [SCB](https://www.scb.se/en/finding-statistics/statistics-by-subject-area/prices-and-consumption/consumer-price-index/consumer-price-index-cpi/pong/tables-and-graphs/cpi-with-fixed-interest-rate-cpif-cpif-ct-and-cpif-xe/cpif-annual-changes/).\n\n\n```python\ndef get_swedish_cpi():\n  \"\"\" Returns the CPI as a monthly percentage change.\n  For more information: https://github.com/kirajcg/pyscbwrapper/blob/master/pyscbwrapper.ipynb\n  \"\"\"\n  import re\n  from pyscbwrapper import SCB\n  scb = SCB('en', 'PR', 'PR0101', 'PR0101A', 'KPIFFMP')\n  scb.set_query(month=scb.get_variables()['month'])\n  data = scb.get_data()['data']\n  my_list = []\n  for obj in data:\n    date_scb_formatted = obj['key'][0].strip()  # this looks like '2020M06'\n    year_month_search = re.search('^(\\d{4})M(\\d{2})$', date_scb_formatted)\n    datetime_object = datetime.strptime('{}-{}-01'.format(year_month_search.group(1), year_month_search.group(2)), '%Y-%m-%d')\n    my_list.append({'date': datetime_object,\n                    'pct_change': float(obj['values'][0])/100\n                    })\n  cpi= pd.DataFrame(my_list)\n  cpi = cpi.set_index('date')\n  return cpi\n\nsw_cpi = get_swedish_cpi()\n\nplot_cpi_on_unit(sw_cpi, unit='SEK')\n```\n   \n![png](inflation-looking-back/inflation-looking-back_16_0.png)\n","excerpt":""},"previousPost":{"slug":"inflation-planning-future-cash-flows","frontmatter":{"title":"Inflation - Planning Forward!","description":"How to plan for future cash flows taking into account inflation, taxes and fees.","date":"May 23, 2021","topic":{"id":"investing","name":"Investing","image":"investing.png","description":"The piggy bank digests a good amount of the savings! There is only one way to get away ... investing. BUT, there is a hidden enemy, Speculation!","color":"bg-green-300"},"tags":[{"id":"python","name":"python","image":"python-header.png","description":"Python is very handy in investing","color":"bg-green-300","icon":"python.svg"}],"author":{"id":"chris","name":"Chris","image":"https://s.gravatar.com/avatar/db809ecfa64d56da4bd9704c8393005a?s=80","description":"Software Engineer, passionate about ..."},"img":"/static/inflation.jpeg","colab":"https://drive.google.com/file/d/13aiLUQUIXhfjfnO_20U4Dap0tsfRiF-B/view?usp=sharing"},"excerpt":"","content":"\nInflation is the reason behind the erosion of the value of money over time. 1\\$ today is more valuable than 1\\$ after 5 years (given a positive Inflation rate). I will not get into the details of what inflation is, since there is lots of literature around that.\n\nIn this article I will showcase how to plan the financing of future expenses by including inflation, taxes on earnings and annual fees.\n\nLet's see that with an example. Let's assume that a person decides a job break for 3 years. Estimates his/her monthly expenses to be 300\\$. What is the initial amount of money the person needs to have to be able to fulfill their goal?\n\nThe quick response to that is $3 * 12 * 300 = 10800$\\$! but that is not actually true due to the inflation. Let's (for the sake of the example) say that the inflation is 2% per year. That means that 1\\$ today will be valued at $1*\\frac{1}{1 + .02}=0.9804$\\$ in one year from now.\n\nSo, for the first year, the person will pay 3600\\$ but the actual cost of 3600\\$ today is $3600*(1+.02)^1 =3672$\\$. That means that there are $3672-3600=72$\\$ that are missing and should be added to the initial amount. The second year the person will need to pay 3600 again, but the value today is $3600*(1+.02)^2=3745.44$\\$. The third year, the situation is the same and the calculated value for the 3600\\$ would today be $3600*(1+.02)^3=3820.348$\\$.\n\n> Note: the notation $(1+i)^n$ where i is the annual inflation rate and n is the periods in years, is something we discussed in the [Geometric Progression and the Compounding of the Returns](/post/geometric-progression-and-compounding-of-returns) article. Think of inflation as compounding with negative rate.\n\nSo far, the deficit for the first year is 72, for the second year is 145 and for the third year is 220. A total of 437\\$ needs to be added to our initial thought of 10800!\n\nThe example above can easily be extended to loan payments, house rent or even pension forecasting.\n\nLet's get into code and replicate the scenario above.\n\n<details><summary>Package Installation</summary>\n<p>\n\n```python\n%%capture\nimport pandas as pd\nimport numpy as np\nimport ipywidgets as widgets\nfrom IPython.display import display\n%matplotlib inline\n```\n\n</p>\n</details>\n\n```python\nmonthly_liabilities = 300\nyears = 3\nannual_liabilities = 12 * monthly_liabilities\ninflation_rate = 0.02\nliabilities = pd.Series(data=[annual_liabilities for i in range(years)], index=[i+1 for i in range(years)])\n\ndef liabilities_inflated(liabilities, inflation_rate):\n  years = liabilities.index\n  inflation_over_years = pd.Series(data=(1+inflation_rate)**years, index=years)\n  return liabilities * inflation_over_years\n\ninflated_liabilities = liabilities_inflated(liabilities, inflation_rate)\nprint(f\"Liabilities per year: {list(liabilities.values)}, \\\n        \\nInflated liabilities: {list(inflated_liabilities.values)}, \\\n        \\nTotal amount needed today: {inflated_liabilities.sum():.2f}, \\\n        \\nNo inflation case: {liabilities.sum():.2f}\")\n```\n    Liabilities per year: [3600, 3600, 3600],         \n    Inflated liabilities: [3672.0, 3745.44, 3820.3488000000007],         \n    Total amount needed today: 11237.79,         \n    No inflation case: 10800.00\n\n\n## Balancing inflation through investing\n\nInflation is eroding the value of money when they stand still! However, a balanced situation can be achieved if the money is invested to something that yields a return equal (or even better, more) than the inflation rate. There are several options to that, from 0 risk saving accounts that pay an interest, to a type of bond that increases the risk a bit and gives a better return (or even inflation-adjusted bonds), to more risky assets like equity funds that might yield an even better return.\n\nIn any case, we should take into account the taxes on profits and the administration fees each investment scenario requires.\n\nLet's go back to our example and say that we found a savings account that pays 2% annually in interest without fees and taxes. That would mean that we could invest 10800 to this account today and each year pay out the bill.\n\nBut what if there was a 10% tax on the profits from this interest? How much money would we need today to start with?\n\n```python\ninvestment_annual_return = 0.02\ninvestment_profit_tax = 0.1\n```\n\n```python\ndef discount(t, r, earnings_tax):\n  \"\"\"\n    Computes the amount needed today which when invested for t periods with\n    an r return per period and earning_tax on the profits, will equal to 1$  \n  \"\"\"\n  return (1 + r - r*earnings_tax)**-t \n\ndef present_value(liabilities, return_annual, earnings_tax):\n  \"\"\"\n    Given a list of liabilities, an annual return and tax rate on earnings,\n    returns the amount of money needed today.\n  \"\"\"\n  dates = liabilities.index\n  discounts = discount(dates, return_annual, earnings_tax)\n  return (discounts * liabilities).sum()\n```\n\n```python\npresent_value(inflated_liabilities, investment_annual_return, investment_profit_tax)\n```\n    10842.491757684631\n\n\nMoving forward, lets say that instead of a savings account we invest in funds that have an annual return of 2%, a profit tax of 10% and an annual administration fee of 0.5% on the total invested amount.\n\nWhat should the initial investment be?\n\n```python\nannual_fee = .005 # percentage of total amount per year\n```\n\n```python\ndef present_value_with_fees(liabilities, return_annual, earnings_tax, annual_fee):\n  dates = liabilities.index\n  discounts = discount(dates, return_annual, earnings_tax)\n  liabilities_with_fees = [liabilities[len(dates) +1 - i] * (1-annual_fee)**-i for i in list(dates)[::-1]]\n  return ((discounts * liabilities_with_fees).values).sum()\n```\n\n```python\npresent_value_with_fees(inflated_liabilities, investment_annual_return, investment_profit_tax, annual_fee)\n```\n    10951.755210394398\n\nIt becomes apparent that taxes and fees play an important role in calculating future cash flows.\n\n## The Funding Ratio\n\nThe funding ratio is a percentage that shows how much our current assets can contribute to future cash flows. A 100% funding ratio means that the initial amount of assets will be just enough to fulfill our goals. A ratio below 100% means that we will need more assets to cover for the future flows and a ratio more than 100% means that we are overfunded and as such we have a surplus of money we can use to fund other goals.\n\n\n```python\ndef funding_ratio(current_assets_value, liabilities, return_annual, earnings_tax, annual_fee):\n  return 100*current_assets_value/present_value_with_fees(liabilities, return_annual, earnings_tax, annual_fee)\n\ndef show_funding_ratio(monthly_liabilities, years, inflation_rate, current_assets_value, return_annual, earnings_tax, annual_fee):\n  annual_liabilities = 12 * monthly_liabilities\n  liabilities = pd.Series(data=[annual_liabilities for i in range(years)], index=[i+1 for i in range(years)])\n  inflated_liabilities = liabilities_inflated(liabilities, inflation_rate)\n  fr = funding_ratio(current_assets_value, inflated_liabilities, return_annual, earnings_tax, annual_fee)\n  print(f'{fr:.2f}')\n```\n\n```python\nfunding_ratio(10951.76, inflated_liabilities, investment_annual_return, investment_profit_tax, annual_fee)\n```\n    100.00004373368022\n\n\nBelow I have included a widget which helps me plan for my future goals. I will try to have it as an HTML widget at some point but for the ones who are interested try the [colab](https://drive.google.com/file/d/13aiLUQUIXhfjfnO_20U4Dap0tsfRiF-B/view?usp=sharing) representation of this article. \n\n```python\ncontrols = widgets.interactive(show_funding_ratio,\n                               monthly_liabilities = widgets.IntSlider(min=100, max=100000, step=100, value=300),\n                               years = widgets.IntSlider(min=3, max=100, step=1, value=3),\n                               inflation_rate = widgets.FloatSlider(min=0.01, max=0.3, step=.01, value=.02),\n                               current_assets_value = widgets.IntSlider(min=10000, max=30000000, step=1000, value=10800),\n                               return_annual = widgets.FloatSlider(min=0.01, max=0.2, step=.01, value=.08),\n                               earnings_tax = widgets.FloatSlider(min=0.1, max=.5, step=.02, value=.3),\n                               annual_fee = widgets.FloatSlider(min=0.01, max=.05, step=.01, value=.03))\ndisplay(controls)\n```\n\nEnjoy!"},"nextPost":{"slug":"modern-portfolio-theory-gmv-msr-mixed","frontmatter":{"title":"Modern Portfolio Theory - Part 2","description":"Global Minimum Variance (GMV), Maximum Sharpe Ratio (MSR), Capital Allocation Line (Cal) and the mixed portfolio.","date":"June 21, 2021","topic":{"id":"investing","name":"Investing","image":"investing.png","description":"The piggy bank digests a good amount of the savings! There is only one way to get away ... investing. BUT, there is a hidden enemy, Speculation!","color":"bg-green-300"},"tags":[{"id":"python","name":"python","image":"python-header.png","description":"Python is very handy in investing","color":"bg-green-300","icon":"python.svg"}],"author":{"id":"chris","name":"Chris","image":"https://s.gravatar.com/avatar/db809ecfa64d56da4bd9704c8393005a?s=80","description":"Software Engineer, passionate about ..."},"img":"/static/nobel-price.jpg","colab":"https://colab.research.google.com/drive/1UhsvOExkQsHE_wIBzQR9rqwcKUSI_FZr?usp=sharing"},"excerpt":"","content":"\nPreviously in [Modern Portfolio Theory - Part 1](/post/modern-portfolio-theory) we located the global minimum variance portfolio (GMV) on the Efficient Frontier. In [Inflation - Planning Forward!](/post/inflation-planning-future-cash-flows) we showed how inflation drags down the real return of an investment. \n\nWhile GMV would pose the minimum (estimated) risk for an investor, it might not be the one that outperforms inflation. In addition to that, government bonds are considered very low risk and yield an annual return which is the profit for the investor. When constructing a portfolio of assets that are riskier, the expectation on return should be higher. A return that surpasses inflation and bond returns should be the goal.\n\nQuoting from [Investopedia - Risk-Free Rate Of Return](https://www.investopedia.com/terms/r/risk-freerate.asp)\n\n> The risk-free rate of return is the theoretical rate of return of an investment with zero risk. The real risk-free rate can be calculated by subtracting the current inflation rate from the yield of the Treasury bond matching your investment duration.\n\nBack to the [wikipedia](https://en.wikipedia.org/wiki/Modern_portfolio_theory) article on Modern Portfolio Theory we notice some pretty interesting aspects. \n\n![jpg](https://upload.wikimedia.org/wikipedia/commons/e/e1/Markowitz_frontier.jpg)\n\n1. There can be a portfolio which yields the risk-free rate and has ~0 standard deviation. It is with minimal risk. That can be a government bond/bill/note for example.\n2. When we start mixing low risk assets (like bonds) with risky assets (like stocks) the return increases but it cannot cross above a line. That, is presented in the graph above with the `Best possible CAL` line which is the Efficient Frontier of the portfolios that hold both risky and non-risky assets. It is called Capital Allocation Line (CAL) or Capital Market Line (CML).\n3. There is a point where the line touches the risky asset portfolios Efficient Frontier (`Tangency Portfolio` or `Maximum Sharpe Ratio Portfolio`).\n\n> $Sharpe Ratio = \\frac{R_p - R_f}{\\sigma_p}$ where \n> * $R_p$ = Portfolio return\n> * $R_f$ = Risk free rate\n> * $\\sigma_p$ = Portfolio standard deviation\n\nThe point in the graph that gives us the best possible return for every unit of risk we take is called `Maximum Sharpe Ratio Portfolio`.\n\n\n<details><summary>Package Installation</summary>\n<p>\n\n```python\n%%capture\n%pip install yahoofinancials\nfrom yahoofinancials import YahooFinancials\nimport pandas as pd\nimport matplotlib\nimport matplotlib.lines as mlines\nimport matplotlib.pyplot as plt\nimport dateutil.parser\nimport numpy as np\nfrom scipy.optimize import minimize\n```\n\n</p>\n</details>\n\n<details><summary>Helper Functions</summary>\n<p>\n\n```python\ndef retrieve_stock_data(symbol, start, end):\n    \"\"\"Fetches daily stock prices from Yahoo Finance\"\"\"\n    json = YahooFinancials(symbol).get_historical_price_data(start, end, \"daily\")\n    df = pd.DataFrame(columns=[\"adjclose\"])\n    for row in json[symbol][\"prices\"]:\n        d = dateutil.parser.isoparse(row[\"formatted_date\"])\n        df.loc[d] = [row[\"adjclose\"]]\n    df.index.name = \"date\"\n    return df\n\ndef arithmetic_returns(S):\n    \"\"\"Returns the arithmetic returns. (price_today - price_yesterday)/price_yesterday\"\"\"\n    return S.pct_change().dropna()\n\ndef annualize_rets(r, periods_per_year):\n    compounded_growth = (1+r).prod()\n    n_periods = r.shape[0]\n    return compounded_growth**(periods_per_year/n_periods)-1\n\ndef portfolio_return(weights, returns):\n    return weights.T @ returns\n\ndef portfolio_volatility(weights, covariance_matrix):\n    return (weights.T @ covariance_matrix @ weights)**0.5\n\ndef generate_returns_dataframe(symbols_list, d_from=\"2020-01-01\", d_to=\"2021-01-01\"):\n    \"\"\"Generates a DataFrame with daily returns for a list of Symbols.\"\"\"\n    returns = pd.DataFrame()\n    for symbol in symbols_list:\n        stock_prices = retrieve_stock_data(symbol, d_from, d_to)\n        rets = arithmetic_returns(stock_prices).dropna()\n        rets.columns = [symbol]\n\n        if returns.empty:\n            returns = rets\n        else:\n            returns = returns.merge(rets, left_index=True, right_index=True)\n    return returns\n\ndef global_minimum_variance(returns, covariance_matrix):\n  \"\"\"Returns the weights of the GMV portfolio\"\"\"\n  n = returns.shape[0]\n  weights_sum_to_1 = {\n      'type': 'eq',\n      'fun': lambda weights: np.sum(weights) - 1\n  }\n  result = minimize(portfolio_volatility, np.repeat(1/n, n), args=(covariance_matrix, ),\n                    method=\"SLSQP\", options={'disp': False},\n                    constraints=(weights_sum_to_1), bounds=((0.0, 1.0),)*n)\n  return result.x\n\ndef efficient_frontier_dataframe(annualized_returns, covariance_matrix): \n  # first we construct 10 pairs of weights like [(0.1,0.9), (0.2,0.8) ...]\n  weights = [np.array([w, 1-w]) for w in np.linspace(0, 1, 10)]\n\n  # then we calculate the return of the portfolio for each pair of weights\n  portfolio_returns = [portfolio_return(w, annualized_returns) for w in weights]\n\n  # and the volatility of the portfolio for each pair of weights\n  vols = [portfolio_volatility(w, covariance_matrix) for w in weights]\n\n  return pd.DataFrame({\n      \"Return\": portfolio_returns, \n      \"Volatility\": vols,\n      \"weights\": weights\n  })\n\ndef print_weights_on_graph(ax, x, y, val):\n  \"\"\"Adds the weight on the efficient frontier\"\"\"\n  a = pd.concat({'x': x, 'y': y, 'val': val}, axis=1)\n  for i, point in a.iterrows():\n    prettified_p = f\"({round(point['val'][0], 2)},{round(point['val'][1], 2)})\"\n    ax.text(point['x'], point['y'], prettified_p)\n\ndef plot_custom_legend():\n  \"\"\"Adds a custom legend for the different points on the graph\"\"\"\n  blue_star = mlines.Line2D([], [], color='blue', marker='*', linestyle='None',\n                            markersize=10, label=f\"MSR\")\n  red_square = mlines.Line2D([], [], color='red', marker='s', linestyle='None',\n                            markersize=10, label=f\"GMV\")\n  purple_triangle = mlines.Line2D([], [], color='green', marker='^', linestyle='None',\n                            markersize=10, label=f\"Mix\")\n\n  plt.legend(handles=[blue_star, red_square, purple_triangle])\n```\n\n</p>\n</details>\n\n```python\nSTOCK_SYMBOLS = ['MSFT', 'APT']\nreturns = generate_returns_dataframe(STOCK_SYMBOLS)\ncovariance_matrix = returns.cov()\nannualized_returns = annualize_rets(returns, 252)\ngmv = global_minimum_variance(annualized_returns, covariance_matrix)\n```\n\n## Capital Allocation Line & Maximum Sharpe Ratio Portfolio (MSR)\n\nSimilar to what we did with the GMV portfolio (in [Modern Portfolio Theory - Part 1](/post/modern-portfolio-theory)), we will do with finding the MSR Portfolio. Instead of trying to minimize the volatility, we will maximize the sharpe ratio. To achieve that, we will use the exact same quadratic programming approach and the `minimize` function from `scipy`.\n\nHowever, to turn maximization into minimization, we will do a simple trick! we will minimize the negative value of the sharpe ratio :) \n\n\n```python\ndef maximum_sharpe_ratio(returns, covariance_matrix, risk_free_rate):\n  \"\"\"Returns the weights of the MSR portfolio\"\"\"\n  n = returns.shape[0]\n  weights_sum_to_1 = {\n      'type': 'eq',\n      'fun': lambda weights: np.sum(weights) - 1\n  }\n\n  def negative_sharpe_ratio(weights, returns, covariance_matrix, risk_free_rate):\n    p_rets = portfolio_return(weights, returns)\n    p_vol = portfolio_volatility(weights, covariance_matrix)\n    return -(p_rets - risk_free_rate)/p_vol\n\n  result = minimize(negative_sharpe_ratio, np.repeat(1/n, n),\n                    args=(returns, covariance_matrix, risk_free_rate),\n                    method=\"SLSQP\", options={'disp': False},\n                    constraints=(weights_sum_to_1), bounds=((0.0, 1.0),)*n)\n  return result.x\n```\n\n\n```python\nrisk_free_rate = 0.03\nmsr = maximum_sharpe_ratio(annualized_returns, covariance_matrix, risk_free_rate)\nmsr\n```\n  array([0.75444897, 0.24555103])\n\n## Plotting GMV, MSR, CAL & Mixed portfolio\n\n```python\n# get the efficient frontier as dataframe and plot it\nef = efficient_frontier_dataframe(annualized_returns, covariance_matrix)\nax = ef.plot(x=\"Volatility\", y=\"Return\", style=\".-\", figsize=(14,7),\n             title=\"2 Asset Portfolio Risk/Return\", legend=False)\nax.set_xlim(left=0)\nplt.ylabel(\"Return\")\n\n# show the different weights on the efficient frontier\nprint_weights_on_graph(ax, ef.Volatility, ef.Return, ef.weights)\n\n# find the MSR point and add a marker\nrets_msr = portfolio_return(msr, annualized_returns)\nvol_msr = portfolio_volatility(msr, covariance_matrix)\nax.plot(vol_msr, rets_msr, 'b*', markersize=10)\n\n# construct and plot the Capital Allocation Line\ncal_x = np.arange(0, vol_msr, (vol_msr-0)/100)\ncal_y = np.arange(risk_free_rate, rets_msr, (rets_msr-risk_free_rate)/100)\nax.plot(cal_x, cal_y, color=\"green\", linestyle=\"dashed\")\n\n# find the GMV point and add a marker\nrets_gmv = portfolio_return(gmv, annualized_returns)\nvol_gmv = portfolio_volatility(gmv, covariance_matrix)\nax.plot(vol_gmv, rets_gmv, 'rs', markersize=10)\n\n# locate the Mixed portfolio on CAL that has less risk than the GMV\nidx = np.argwhere(np.diff(np.sign(rets_gmv - cal_y))).flatten()\nax.plot(cal_x[idx], cal_y[idx], 'g^', markersize=10)\n\n# Add a custom legend for the markers\nplot_custom_legend()\nplt.show()\n```\n\n![png](modern-portfolio-theory-gmv-msr-mixed/modern-portfolio-theory-gmv-msr-mixed-8-0.png)\n    \n\n## MSR vs. GMV vs. Mixed Portfolio\n\nFrom the graph above we can pinpoint 3 interesting portfolios:\n\n* The GMV portfolio which depends solely on the covariance matrix.\n* The MSR portfolio which depends both on the covariance matrix and the expected returns.\n* The Mixed Portfolio which can yield same return as the GMV but with less risk.\n\nSo far, we took advantage of the historical data and constructed some portfolios. However, **historical returns are no guarantee of future returns**. Estimating returns is very difficult and requires experience, deep knowledge of the respective assets, continuous monitoring of the market and much more.\n\nSo, which portfolio is best to hold? The answer to that cannot be given with certainty!\n\nGMV does not take into account returns (or estimated expected returns) and thus makes it easier to calculate, but at the same time, constructing the covariance matrix for a long list of assets falls under the well known [Curse of Dimensionality](https://en.wikipedia.org/wiki/Curse_of_dimensionality) problem.\n\nMSR poses the difficulty of estimating expected returns and thus includes increased risk.\n\nThe mixed portfolio combines non risky assets with risky assets while lowering the risk. However, the covariance matrix is yet there to calculate.\n\nAll in all, each portfolio includes risk, which we call **model risk**. There are several ways to tackle this model risk and I will try to address them in future articles.\n\nUntil then, enjoy!\n"}},"tags":[{"id":"python","name":"python","image":"python-header.png","description":"Python is very handy in investing","color":"bg-green-300","icon":"python.svg","slug":"python","count":13},{"id":"statistics","name":"statistics","image":"statistics.jpg","description":"Statistics is the discipline that concerns the collection, organization, analysis, interpretation and presentation of data. - Wikipedia","color":"bg-green-300","icon":"statistics.svg","slug":"statistics","count":4},{"id":"cryptos","name":"cryptos","image":"bitcoin.png","description":"The amazing world of Blockchain opens one more chapter in the Investing.","color":"bg-green-300","icon":"bitcoin.svg","slug":"cryptos","count":1}],"sortedTopics":[{"id":"investing","name":"Investing","image":"investing.png","description":"The piggy bank digests a good amount of the savings! There is only one way to get away ... investing. BUT, there is a hidden enemy, Speculation!","color":"bg-green-300","slug":"investing","count":10},{"id":"mathematics","name":"Mathematics","image":"mathematics.png","description":"Investing, as part of the Science of Finance, is subject to the lows of Mathematics!","color":"bg-green-300","slug":"mathematics","count":4},{"id":"automation","name":"Automation","image":"automation.jpg","description":"Spending time to do the same thing over and over again is tedious! Thus, I like to automate as much as possible.","color":"bg-green-300","slug":"automation","count":3}],"allTopics":[{"id":"mathematics","name":"Mathematics","image":"mathematics.png","description":"Investing, as part of the Science of Finance, is subject to the lows of Mathematics!","color":"bg-green-300"},{"id":"automation","name":"Automation","image":"automation.jpg","description":"Spending time to do the same thing over and over again is tedious! Thus, I like to automate as much as possible.","color":"bg-green-300"},{"id":"investing","name":"Investing","image":"investing.png","description":"The piggy bank digests a good amount of the savings! There is only one way to get away ... investing. BUT, there is a hidden enemy, Speculation!","color":"bg-green-300"}],"slug":"inflation-looking-back"},"__N_SSG":true}